PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n";

ID : < LETTERS > (< LETTERS > | < INTEGER > );

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< EQUALS : "=" > |
	< DIF : "!=" > |
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< OPEN_SQ_BRACK : "[" > |
	< CLOSE_SQ_BRACK: "]" > |
	< OPEN_CURL_BRACK : "{" > |
	< CLOSE_CURL_BRACK : "}" > |
	< LT : "<" > |
	< GT : ">" > |
	< LE : "<=" > |
	< GE : ">=" > |
	< AND : "&&" > |
	< OR : "||" > |
	< NOT : "!" > |
	< INTEGER : (["0" - "9"])+ > |
	< LETTERS : (["a" - "z"]) | (["A" - "Z"])+ > |
	< SEMI_COLON : ";" > |
	< COLON : ":" > |
	< COMMA : "," > |
	< DOT : "." > |
	< FOR : "for" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< SWTICH : "switch" > |
	< CASE : "case" > |
	< THIS : "this" > |
	< IMPORT : "import" > |
	< EXTENDS : "extends" > |
	< PUBLIC : "public" > |
	< RETURN : "return" > |
	< STATIC : "static" > |
	< VOID : "void" > |
	< MAIN : "main" > |
	< STRING : "String" > |
	< INT : "int" > |
	< BOOLEAN : "boolean" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< LENGTH : "length" > |
	< NEW : "new" > |
	< CLASS : "class" >
;

Start : AdditiveExpression <EOF> ;

AdditiveExpression :
	MultiplicativeExpression
	(
		(< PLUS > | < MINUS >)
		MultiplicativeExpression
	)?
;

MultiplicativeExpression :
	Factor
	(
		(< TIMES > | < DIVIDE >)
		Factor
	)?
;

Factor :
	< INTEGER > |
	< MINUS> Factor |
	< OPEN_PAREN > AdditiveExpression < CLOSE_PAREN >
;

/* Change - na gramatica o import td ta envolvido em {} aka 0 ou + vezes */
ImportDeclaration :
    ( < IMPORT > ID ( < DOT > ID )* < SEMI_COLON > )*
;

/*
Type : 
	( < INT > < OPEN_SQ_BRACK > < CLOSE_SQ_BRACK > ) |
	< BOOLEAN > |
	< INT > |
	< ID >
;

Expression : 
	( Expression ( < AND > | < LT > | < PLUS > | < MINUS > | < TIMES > | < DIVIDE > ) Expression ) |
	( Expression < OPEN_SQ_BRACK > Expression < CLOSE_SQ_BRACK >) |
	( Expression < DOT > < LENGTH > ) |
	( Expression < DOT > < ID > < OPEN_PAREN > ( Expression ( < COMMA > Expression )* )? < CLOSE_PAREN > ) |
	< INTEGER > | < TRUE > | < FALSE > | < ID > | < THIS > |
	( < NEW > < INT > < OPEN_SQ_BRACK > Expression < CLOSE_SQ_BRACK > ) | 
	( < NEW > < ID > < OPEN_PAREN > < CLOSE_PAREN > ) |
	( < NOT > Expression ) |
	( < OPEN_PAREN > Expression < CLOSE_PAREN > )
;

Statement :
	( < OPEN_CURL_BRACK > ( Statement )* < CLOSE_CURL_BRACK > ) |
	( 	
		< IF > < OPEN_PAREN > Expression < CLOSE_PAREN > 
			Statement
		< ELSE >
			Statement
	) |
	(
		< WHILE > < OPEN_PAREN > Expression < CLOSE_PAREN > Statement
	) |
	( Expression < SEMI_COLON > ) | 
	( < ID > < EQUALS > Expression < SEMI_COLON >) |
	( < ID > < OPEN_SQ_BRACK > Expression < CLOSE_SQ_BRACK > < EQUALS > Expression < SEMI_COLON >)
;

VarDeclaration :
	Type < ID > < SEMI_COLON >
;

MethodDeclaration :
	(
		< PUBLIC >
		Type
		< ID >
		< OPEN_PAREN >
			(
				Type < ID > ( < COMMA > Type < ID > )*
			)?
		< CLOSE_PAREN >
		< OPEN_CURL_BRACK >
			( VarDeclaration )*
			( Statement )*
			< RETURN > Expression < SEMI_COLON >
		< CLOSE_CURL_BRACK >
	) |
	(
		< PUBLIC > < STATIC > < VOID > < MAIN >
		< OPEN_PAREN > < STRING > < OPEN_SQ_BRACK > < CLOSE_SQ_BRACK > < ID > < CLOSE_PAREN >
		< OPEN_CURL_BRACK >
			( VarDeclaration )*
			( Statement )*
		< CLOSE_CURL_BRACK >
	)
;

ClassDeclaration :
	< CLASS > ID 
	(
		< EXTENDS > ID 
	)? 
	< OPEN_CURL_BRACK > 
		( VarDeclaration )* 
		( MethodDeclaration )* 
	< CLOSE_CURL_BRACK > 
	< SEMI_COLON >
;
*/