PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES=false;

SKIP : " " | "\t" | "\r" | "\n" | < "//" (~["\n"])* > | < "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/" >;

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< EQUALS : "=" > |
	< DIF : "!=" > |
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< OPEN_SQ_BRACK : "[" > |
	< CLOSE_SQ_BRACK: "]" > |
	< OPEN_CURL_BRACK : "{" > |
	< CLOSE_CURL_BRACK : "}" > |
	< LT : "<" > |
	< GT : ">" > |
	< LE : "<=" > |
	< GE : ">=" > |
	< AND : "&&" > |
	< OR : "||" > |
	< NOT : "!" > |
	< INTEGER : (["0" - "9"])+ > |
	< SEMI_COLON : ";" > |
	< COLON : ":" > |
	< COMMA : "," > |
	< DOT : "." > |
	< FOR : "for" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< SWTICH : "switch" > |
	< CASE : "case" > |
	< THIS : "this" > |
	< IMPORT : "import" > |
	< EXTENDS : "extends" > |
	< PUBLIC : "public" > |
	< RETURN : "return" > |
	< STATIC : "static" > |
	< VOID : "void" > |
	< MAIN : "main" > |
	< STRING : "String" > |
	< INT : "int" > |
	< BOOLEAN : "boolean" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< LENGTH : "length" > |
	< NEW : "new" > |
	< CLASS : "class" > |
	< IDD : ( < LETTER > | < UNDERSCORE > ) ( < LETTER > | < INTEGER > | < UNDERSCORE > )* > |
    < LETTER : ( < LOWER_CASE > | < UPPER_CASE > ) > |
    < LOWER_CASE : ["a" - "z"] > |
    < UPPER_CASE : ["A" - "Z"] > |
    < UNDERSCORE : "_" >
;

Start :
    ImportDeclaration
    ClassDeclaration
    <EOF>
;

AdditiveExpression :
	MultiplicativeExpression
	(
		(< PLUS > | < MINUS >)
		MultiplicativeExpression
	)?
;

MultiplicativeExpression :
	Factor
	(
		(< TIMES > | < DIVIDE >)
	 	( Factor | Expression)
	)?
;

Factor :
	< IDD > |
	< INTEGER > |
	< MINUS> Factor |
	< OPEN_PAREN > AdditiveExpression < CLOSE_PAREN >
;

ImportDeclaration :
    ( < IMPORT > < IDD > ( < DOT > < IDD > )* < SEMI_COLON > )*
;

ClassDeclaration :
	< CLASS > < IDD >
	(
		< EXTENDS > < IDD >
	)?
	< OPEN_CURL_BRACK >
		( VarDeclaration )*
		( MethodDeclaration )*
	< CLOSE_CURL_BRACK >
;

VarDeclaration :
	Type < IDD > < SEMI_COLON >
;

MethodDeclaration :
    < PUBLIC >
    (
        Type
        < IDD >
        < OPEN_PAREN >
            (
            Type < IDD > ( < COMMA > Type < IDD > )*
            )?
        < CLOSE_PAREN >
        < OPEN_CURL_BRACK >
            ( SCAN 2 VarDeclaration )*
            ( Statement )*
            < RETURN > Expression < SEMI_COLON >
        < CLOSE_CURL_BRACK >
    |
        < STATIC > < VOID > < MAIN >
        < OPEN_PAREN >
            < STRING > < OPEN_SQ_BRACK > < CLOSE_SQ_BRACK > < IDD >
        < CLOSE_PAREN >
        < OPEN_CURL_BRACK >
            ( SCAN 2 VarDeclaration )*
            ( Statement )*
        < CLOSE_CURL_BRACK >
    )
;

Statement :
	( < OPEN_CURL_BRACK > ( Statement )* < CLOSE_CURL_BRACK > ) |
	(
		< IF > < OPEN_PAREN > Expression < CLOSE_PAREN >
			Statement
		< ELSE >
			Statement
	) |
	(
		< WHILE > < OPEN_PAREN > Expression < CLOSE_PAREN > Statement
	) |
	SCAN 2 (< IDD > (( < EQUALS > Expression) | (<OPEN_SQ_BRACK> Expression <CLOSE_SQ_BRACK> < EQUALS > Expression)) < SEMI_COLON > ) |
	Expression < SEMI_COLON >
;


Type : 
	( < INT > ( < OPEN_SQ_BRACK > < CLOSE_SQ_BRACK > )? ) |
	< BOOLEAN > |
	< IDD >
;

Expression :
    And
;

And #void :
    LessThan
    ( < AND > #And LessThan )*
;

LessThan #void :
    AddSub
    ( < LT > AddSub )*
;

AddSub #void :
    (MultDiv
    (
    ( < PLUS > MultDiv) |
    ( < MINUS > MultDiv #Minus(>0))
    )*) #Add(>1)
;

MultDiv #void :
    (Not
    (
    ( < TIMES > Not ) |
    ( < DIVIDE > Not #Inverse(>0))
    )*) #Mult(>1)
;

Not #void :
    < NOT > ( Not ) |
    Terminations
;

Terminations #void :
    Terminal ( Array | DotStatement )*
;

Terminal #void :
    < INTEGER > #Int |
    < TRUE > |
    < FALSE > |
    < IDD > #Id |
    < THIS > |
    ( < OPEN_PAREN >
        Expression
    < CLOSE_PAREN > ) |
    New
;

New #void :
    < NEW >
    (
        ( < INT >
          < OPEN_SQ_BRACK >
            Expression
          < CLOSE_SQ_BRACK > )
        |
        ( < IDD >
          < OPEN_PAREN >
          < CLOSE_PAREN >
        )
    )
;

Array #void :
    < OPEN_SQ_BRACK >
        Expression
    < CLOSE_SQ_BRACK >
;

DotStatement #void :
    < DOT >
    ( < LENGTH > | CallExpression )
;

CallExpression #void :
    < IDD >
    < OPEN_PAREN >
        ( Expression ( < COMMA > Expression )* )?
    < CLOSE_PAREN >
;